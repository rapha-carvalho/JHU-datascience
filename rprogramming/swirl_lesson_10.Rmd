---
title: "Functions"
author: "Raphael Carvalho"
date: "01/06/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# lapply and sapply

The lapply() function takes a list as input, applies a function to each element of the list, then returns a list of the same length as the original one. Since a data frame is really just a list of vectors (you can see this with as.list(flags)), we can use lapply() to apply the class() function to each column of the flags dataset. Let's see it in action!

Type cls_list <- lapply(flags, class) to apply the class() function to each column of the flags dataset and store the result in a variable called cls_list. Note that you just supply the name of the function you want to apply (i.e. class), without the usual parentheses after it.

```{r 1, echo=TRUE, eval=TRUE}
y <- "https://archive.ics.uci.edu/ml/machine-learning-databases/flags/flag.data"
flags <- read.table(y, header = FALSE, sep = ",")

cls_list <- lapply(flags, class)
```

You may remember from a previous lesson that lists are most helpful for storing multiple classes of data. In this case, since every element of the list returned by lapply() is a character vector of length one (i.e. "integer" and "vector"), cls_list can be simplified to a character vector. To do this manually, type as.character(cls_list).

```{r 2, echo=TRUE, eval=TRUE}
as.character(cls_list)
```

sapply() allows you to automate this process by calling lapply() behind the scenes, but then attempting to simplify (hence the 's' in 'sapply') the result for you. Use sapply() the same way you used lapply() to get the class of each column of the flags dataset and store the result in cls_vect. If you need help, type ?sapply to bring up the documentation.

```{r 3, echo=TRUE, eval=TRUE}
cls_vect <- sapply(flags, class)
```

Columns 11 through 17 of our dataset are indicator variables, each representing a different color. The value of the indicator variable is 1 if the color is present in a country's flag and 0 otherwise.

Therefore, if we want to know the total number of countries (in our dataset) with, for example, the color orange on their flag, we can just add up all of the 1s and 0s in the 'orange' column. Try sum(flags$orange) to see this.

```{r 4, echo=TRUE, eval=TRUE}
sum(flags$orange)
```

First, use flag_colors <- flags[, 11:17] to extract the columns containing the color data and store them in a new data frame called flag_colors. (Note the comma before 11:17. This subsetting command tells R that we want all rows, but only columns 11 through 17.)

```{r 5, echo=TRUE, eval=TRUE}
 flag_colors <- flags[, 11:17]
```

To get a list containing the sum of each column of flag_colors, call the lapply() function with two arguments. The first argument is the object over which we are looping (i.e. flag_colors) and the second argument is the name of the function we wish to apply to each
column (i.e. sum). Remember that the second argument is just the name of the function with
no parentheses, etc.

```{r 6, echo=TRUE, eval=TRUE}
lapply(flag_colors, sum)
```

The result is a list, since lapply() always returns a list. Each element of this list is of length one, so the result can be simplified to a vector by calling sapply() instead of lapply(). Try it now.

```{r 7, echo=TRUE, eval=TRUE}
sapply(flag_colors, sum)
```

Perhaps it's more informative to find the proportion of flags (out of 194) containing each color. Since each column is just a bunch of 1s and 0s, the arithmetic mean of each column will give us the proportion of 1s. (If it's not clear why, think of a simpler situation where you have three 1s and two 0s -- (1 + 1 + 1 + 0 + 0)/5 = 3/5 = 0.6).

```{r 8, echo=TRUE, eval=TRUE}
sapply(flag_colors, mean)
```

In the examples we've looked at so far, sapply() has been able to simplify the result to vector. That's because each element of the list returned by lapply() was a vector of length one. Recall that sapply() instead returns a matrix when each element of the list returned by lapply() is a vector of the same length (> 1). To illustrate this, let's extract columns 19 through 23 from the flags dataset and store the result in a new data frame called flag_shapes. flag_shapes <- flags[, 19:23] will do it.

```{r 9, echo=TRUE, eval=TRUE}
flag_shapes <- flags[, 19:23]
```

The range() function returns the minimum and maximum of its first argument, which should be a numeric vector. Use lapply() to apply the range function to each column of flag_shapes. Don't worry about storing the result in a new variable. By now, we know that lapply() always returns a list.

```{r 10, echo=TRUE, eval=TRUE}
lapply(flag_shapes, range)
```

Do the same operation, but using sapply() and store the result ina variable called shape_mat. 

```{r 11, echo=TRUE, eval=TRUE}
shape_mat <- sapply(flag_shapes, range)
shape_mat
```

As we've seen, sapply() always attempts to simplify the result given by lapply(). It has been successful in doing so for each of the examples we've looked at so far. Let's look at an example where sapply() can't figure out how to simplify the result and thus returns a list, no different from lapply().

When given a vector, the unique() function returns a vector with all duplicate elements removed. In other words, unique() returns a vector of only the 'unique' elements. To see how it works, try unique(c(3, 4, 5, 5, 5, 6, 6)).

```{r 12, echo=TRUE, eval=TRUE}
unique(c(3, 4, 5, 5, 5, 6, 6))
```

We want to know the unique values for each variable in the flags dataset. To accomplish this, use lapply() to apply the unique() function to each column in the flags dataset, storing the result in a variable called unique_vals.

```{r 13, echo=TRUE, eval=TRUE}
unique_vals <- lapply(flags, unique)
#unique_vals
```

Since unique_vals is a list, you can use what you've learned to determine the length of each element of unique_vals (i.e. the number of unique values for each variable). Simplify the result, if possible. Hint: Apply the length() function to each element of unique_vals.

```{r 14, echo=TRUE, eval=TRUE}
sapply(unique_vals, length)
```

Occasionally, you may need to apply a function that is not yet defined, thus requiring you to write your own. Writing functions in R is beyond the scope of this lesson, but let's look at a quick example of how you might do so in the context of loop functions.

 Pretend you are interested in only the second item from each element of the unique_vals list that you just created. Since each element of the unique_vals list is a vector and we're not aware of any built-in function in R that returns the second element of a vector, we will construct our own function.

lapply(unique_vals, function(elem) elem[2]) will return a list containing the second item from each element of the unique_vals list. Note that our function takes one argument, elem, which is just a 'dummy variable' that takes on the value of each element of unique_vals, in turn.

```{r 15, echo=TRUE, eval=TRUE}
 lapply(unique_vals, function(elem) elem[2])
```